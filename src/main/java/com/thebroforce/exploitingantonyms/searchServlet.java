/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.thebroforce.exploitingantonyms;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletContext;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

/**
 *
 * @author redho
 */
@WebServlet(name = "searchServlet", urlPatterns = {"/searchServlet"})
public class searchServlet extends HttpServlet {

    /**
     * Processes requests for both HTTP <code>GET</code> and <code>POST</code>
     * methods.
     *
     * @param request servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException if an I/O error occurs
     */
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException, Exception {
        //response.setContentType("text/html;charset=UTF-8");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        try (PrintWriter out = response.getWriter()) {
            String query = request.getParameter("query");
            int numOfRes = Integer.parseInt(request.getParameter("numOfRes"));
            String id = request.getParameter("id");
            String similarity = request.getParameter("similarity");
            String experimentID = request.getParameter("experimentID");
            ServletContext context = getServletContext();
            
            String propertiesStr = "serverProperties.properties";
            ClassLoader loader = Thread.currentThread().getContextClassLoader();

            Properties props = new Properties();
            InputStream is = null;

            try (InputStream resourceStream = loader.getResourceAsStream(propertiesStr)){
                //  load properties
                props.load(resourceStream);
            } catch (IOException e) {
                System.err.println(e);
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        System.err.println(e);
                    }
                }
            }
            
            // Results to be returned
            String results = "";
            
            boolean didSomethingFancy = false;
            
            File experimentsFolder = new File(props.getProperty("path2experiments"));
            
            if (similarity.equalsIgnoreCase("interleaved") || similarity.equals("topScoresIndependent")) {
                //  Get all dual queries
                List<List<String>> dualQueriesListOfLists = new ArrayList();
        
                for(String term : query.split(" ")) {
                    Set<String> lemmas = new HashSet<>();
                    lemmas.add(term);
                    lemmas.addAll(AntonymsExtJWNL.getAntonyms(term));

                    String[] tempArr = new String[lemmas.size()];
                    tempArr = Arrays.copyOf(lemmas.toArray(tempArr), lemmas.size());
                    dualQueriesListOfLists.add(Arrays.asList(tempArr));
                }
                
                List<String> dualQueriesList = combineLists(dualQueriesListOfLists);

                String[] nResults = new String[dualQueriesList.size()];
                JSONArray[] allResults = new JSONArray[dualQueriesList.size()];
                JSONParser parser = new JSONParser();
                
                for (int i = 0; i < dualQueriesList.size(); i++) {
                    nResults[i] = LuceneSearcher.main(dualQueriesList.get(i), numOfRes, 
                    experimentsFolder + "/" + id + "/DLed_webpages",
                    experimentsFolder + "/" + id + "/index",
                    experimentsFolder + "/" + id + "/filesDownloadedAndWhereToFindThem.json",
                    "BM25Similarity");
                    allResults[i] = (JSONArray)parser.parse(nResults[i]);
                }
                
                if (allResults != null) {
                    //  We got results
                    
                    //  Interleaved
                    if (similarity.equalsIgnoreCase("interleaved")) {
                        String interLeavedResults = "[\n";
                        HashMap resHashMap = new HashMap();

                        boolean shouldContinue = false;
                        int resAdded = 0;
                        int countWas = 0;
                        int i = 0;
                        while (i < dualQueriesList.size()) {

                            for (int j = 0; j < allResults[i].size(); j++) {
                                if(resHashMap.containsKey(((JSONObject)allResults[i].get(j)).get("name")) == false) {
                                    resHashMap.put(((JSONObject)allResults[i].get(j)).get("name"), true);
                                    interLeavedResults = interLeavedResults
                                        .concat("\t")
                                        .concat(((JSONObject)allResults[i].get(j)).toJSONString())
                                        .concat(",\n");
                                    resAdded++;
                                    shouldContinue = true;
                                    break;
                                }
                            }
                            i++;
                            if (resAdded < numOfRes && i == dualQueriesList.size() && countWas != resAdded) {
                                i = 0;
                                countWas = resAdded;
                            }
                        }

                        interLeavedResults = interLeavedResults.concat("]").replace(",\n]", "\n]");
                        didSomethingFancy = true;
                        results = interLeavedResults;
                    } else {
                        String topScoresIndependent = "[\n";
                        HashMap resHashMap = new HashMap();
                        
                        int i = 0;
                        int count = 0;
                        JSONArray arrayOfAllRes = new JSONArray();
                        while(i < allResults.length) {
                            int j = 0;
                            while(j < allResults[i].size()) {
                                if(resHashMap.containsKey(((JSONObject)allResults[i].get(j)).get("name")) == false) {
                                    arrayOfAllRes.add(allResults[i].get(j));
                                    resHashMap.put(((JSONObject)allResults[i].get(j)).get("name"), true);
                                }
                                j++;
                            }
                            i++;
                        }
                        
                        Collections.sort(arrayOfAllRes, new Comparator<JSONObject>() {
                            @Override
                            public int compare(JSONObject jsonObjectA, JSONObject jsonObjectB) {
                                int compare = 0;
                                try
                                {
                                    double valueA = (double) jsonObjectA.get("score");
                                    double valueB = (double) jsonObjectB.get("score");
                                    //  the - ensures biggest score first
                                    return -Double.compare(valueA, valueB);
                                }
                                catch(Exception e)
                                {
                                    System.err.println(e.getMessage());
                                }
                                return compare;
                            }
                        });
                        
                        JSONArray sortedResults = new JSONArray();
                        for (i = 0; i < arrayOfAllRes.size(); i++) {
                            sortedResults.add(arrayOfAllRes.get(i));
                        }
                        
                        i = 0;
                        String sortedRes = "[\n";
                        while (i < numOfRes && i < sortedResults.size()) {
                            sortedRes = sortedRes.concat("\t")
                                    .concat(((JSONObject)sortedResults.get(i)).toJSONString())
                                    .concat(",\n");
                            i++;
                        }
                        sortedRes = sortedRes.concat("]").replace(",\n]", "\n]");
                        results = sortedRes;
                        didSomethingFancy = true;
                        System.err.println(results);
                    }
                    
                }
            }
            
            if (didSomethingFancy == false) results = LuceneSearcher.main(query, numOfRes, 
                experimentsFolder + "/" + id + "/DLed_webpages",
                experimentsFolder + "/" + id + "/index",
                experimentsFolder + "/" + id + "/filesDownloadedAndWhereToFindThem.json",
                similarity);

            out.print(results);
        }
    }
    
    public static List<String> combineLists(List<List<String>> totalList)
    {
        List<String> result = new ArrayList<>(totalList.get(0));

        for(int index = 1; index < totalList.size() ; index++)
        {
            result = combineTwoLists(result, totalList.get(index));
        }
        
        return result;
    }

    // Returns the concat of the two lists
    public static List<String> combineTwoLists(List<String> list1, List<String>   list2) {
        List<String> result = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(String s1 : list1)
        {
            for(String s2: list2)
            {
                sb.setLength(0);
                sb.append(s1).append(' ').append(s2);
                result.add(sb.toString());
            }
        }
        return result;
    }

    // <editor-fold defaultstate="collapsed" desc="HttpServlet methods. Click on the + sign on the left to edit the code.">
    /**
     * Handles the HTTP <code>GET</code> method.
     *
     * @param request servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException if an I/O error occurs
     */
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        try {
            processRequest(request, response);
        } catch(Exception e) {
            System.err.println("Caught: " + e);
        }
    }

    /**
     * Handles the HTTP <code>POST</code> method.
     *
     * @param request servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException if an I/O error occurs
     */
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        try {
            processRequest(request, response);
        } catch(Exception e) {
            System.err.println("Caught: " + e);
        }
        
    }

    /**
     * Returns a short description of the servlet.
     *
     * @return a String containing servlet description
     */
    @Override
    public String getServletInfo() {
        return "Short description";
    }// </editor-fold>

}
