/* global parseInt */

var queryOptions;
var queryOptionsR;

var baseColorHexStr = 'f5f5f5';
var baseColorHexInt = parseInt(baseColorHexStr, 16);

var lKendallArr;
var rTempKendallArr;
var rKendallArr;
var lNamesArr;
var rNamesArr;

function getQueriesUsed() {
    let experimentID = $('#id').val();
    var http = new XMLHttpRequest();
    var url = "getQueriesServlet";

    //  Clear out dual query part of the screen
    $('#searchR').html('');

    http.open("POST", url, true);
    
    http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    
    http.onreadystatechange = function() {
        if(http.readyState === 4 && http.status === 200) {
            let allQueries = http.responseText.replace(/\[/g, "").replace(/\]/g, "")
                .split(',').map(x => x.trim());
            let options = ''; 
            for (let i in allQueries) {
                options = options + '<option>' + allQueries[i] + '</option>';
            }
            queryOptions = options;
            exploitQuery();
        }
    };

    http.send('experimentID=' + experimentID);
}

function search(left) {
    //  Choose correct queryElement
    let queryElement = left ? $('#leftQuery')[0] : $('#rightQuery')[0];
    //  Which id should be passed on
    let id = left ? 'resultsL' : 'resultsR';
    
    //  Choose correct query for search
    let query = left ? $('.custom-combobox')[0].childNodes[0].value : $('.custom-combobox')[1].childNodes[0].value;

    searchDocuments(query, $('#resPerQuery').val(), $('#id').val(), id);
}

function exploitQuery() {
    
    //  Add similarity select on searchL
    $('#searchL').html('<label for="SimilarityL">Similarity: </label>' +
            '<select id="SimilarityL">' +
                '<option>BM25Similarity</option>' +
                '<option>TFIDFSimilarity</option>' +
                '<option>LMDirichletSimilarity</option>' +
                '<option>Interleaved</option>' +
                '<option value="topScoresIndependent">Top-Scores Independent</option>' +
            '</select>');
    
    //  Clear SearchR
    $('#searchR').html();
    
    let selectL = '<div id="leftQuery" class="ui-widget"><select id="combobox">' + queryOptions + '</select>';
    //  Load combobox on DOM
    $('#searchL').append(selectL);
    
    let searchL = '<button type="submit" onclick="javascript:search(true)">Search</button>' +
        '<div id="resultsL"></div></div>';

    //  Add search button and results div
    $('#searchL').append(searchL);
    //  Enable combobox
    $('#combobox').combobox();
    //  Clear the left combobox (should be updated if the #inputs changes
    $('input')[2].value = '';
}

function checkReadyExperiments() {
    var http = new XMLHttpRequest();
    var url = "checkExperimentsServlet";
    
    http.open("POST", url, true);
    http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    
    http.onreadystatechange = function() {
        if(http.readyState === 4 && http.status === 200) {
            let readyExpsArr = http.responseText
                .replace(/\[/g, "").replace(/\]/g, "")
                .split(",").map(x => x.trim());
            let options = '';
            readyExpsArr.forEach((exp) => {
               options += '<option value="'+ exp +'">' + exp + '</option>';
            });
            $('#id').html(options);
            getQueriesUsed();
            return;
        }
    };

    http.send();
}

/*
 * 
 * @param {String} searchQuery Query to lucene
 * @returns {nothing}
 */
function crawlAndIndex() {
    var http = new XMLHttpRequest();
    var url = "crawlAndIndexServlet";
    
    var data = {
        "id": $('#id').val(),
        "resPerQuery": $('#resPerQuery').val(),
        "queries": $('#queries').val().split(',').map(x => x.trim())
    };
    
    http.open("POST", url, true);
    
    http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    
    http.onreadystatechange = function() {//Call a function when the state changes.
        if(http.readyState === 4 && http.status === 200) {
            console.log('You are probably not gonna see this, but your crawling ' +
                'and indexing is done.');
            return;
        }
    };

    http.send('parameters=' + JSON.stringify(data));
    
    alert('Your crawl and indexing has started, you will know it\'s done when the ' +
        'experiment id shows up in querying');
    
}

/*
 * 
 * @param {String} searchQuery Query to lucene
 * @returns {nothing}
 */
function searchDocuments(searchQuery, numOfRes, id, containerId) {
    var query = searchQuery;
    //  choose similarity
    var similarity = containerId === 'resultsL' ? $('#SimilarityL').val() : $('#SimilarityR').val();
    let experimentID = $('#id').val();
    
    containerId === $('#resultsR').html('');
    
    $('#' + containerId).html('');
    
    var http = new XMLHttpRequest();
    var url = "searchServlet";
    var params = "query=" + query + "&numOfRes=" + numOfRes + '&id=' + id + 
        '&similarity=' + similarity + '&experimentID=' + experimentID;
    http.open("POST", url, true);
    
    http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    
    http.onreadystatechange = function() {//Call a function when the state changes.
        if(http.readyState === 4 && http.status === 200) {
            let resObjArr = JSON.parse(http.responseText);
            
            if (resObjArr.length === 0) {
                $('#' + containerId).append('NO RESULTS FOUND');
            }
            let counter = 1;
            resObjArr.forEach(function(res) {
                let rank = res.name.match(/\d+/)[0];
                let namesAndRanks = '';
                
                let first = true;
                res.queries.sort(function(a, b) {
                    return a.rank > b.rank;
                }).forEach(function(q) {
                    let rank = q.rank;
                    if (first) {
                        namesAndRanks += 'Score: ' + res.score + '<br />';
                        first = false;
                    }
                    let ggQuery = q.query.replace(/\+/gm, ' ')
                        .replace(rank, '')
                        .toLowerCase();
                    
                    if (ggQuery.toLowerCase() === query.toLowerCase()) {
                        namesAndRanks += '<b>';
                    }
                        
                    namesAndRanks += ggQuery + ' - #gg: ' + rank;
                    
                    if (ggQuery.toLowerCase() === query.toLowerCase()) {
                        namesAndRanks += '</b>';
                    }
                    
                    namesAndRanks += '<br />';
                });
                $('#' + containerId).append('<div>' + counter + ' ' + '<a target="_blank" href="' + 
                    res.href + '">' + res.href + '</a>' + '<br />' + namesAndRanks + 
                    '</div> <br />');
                counter = counter + 1;
            });
                       
            if (containerId === 'resultsL') {
                lNamesArr = resObjArr.map(x => x.name);
                lKendallArr = [];
                for (let name in lNamesArr) {
                    lKendallArr.push([lNamesArr[name], (parseInt(name) + 1)]);
                }
                var httpNew = new XMLHttpRequest();
                var urlNew = "antonymsServlet";
                var paramsNew = "query=" + query;
                httpNew.open("POST", urlNew, true);

                httpNew.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                httpNew.onreadystatechange = function() {//Call a function when the state changes.
                    if (httpNew.readyState === 4 && httpNew.status === 200) {
                        let responseJSONstr = httpNew.responseText.replace(/,]/g, ']');
                        let responseJSONobj = JSON.parse(responseJSONstr);
                        
                        //  Clear queryOptionsR
                        queryOptionsR = '';
                        cartesianProduct(responseJSONobj.exploited)
                        .forEach((dualQuery) => {
                            queryOptionsR += '<option>' + dualQuery.join(' ') + '</option>';
                        });
                        //  Add similarity select on searchR
                        $('#searchR').html('<label for="SimilarityR">Similarity: </label>' +
                                '<select id="SimilarityR">' +
                                    '<option>BM25Similarity</option>' +
                                    '<option>TFIDFSimilarity</option>' +
                                    '<option>LMDirichletSimilarity</option>' +
                                    '<option>Interleaved</option>' +
                                    '<option value="topScoresIndependent">Top-Scores Independent</option>' +
                                '</select>');

                        let selectR = '<div id="rightQuery" class="ui-widget"><select id="comboboxR">' + queryOptionsR + '</select>';
                        $('#searchR').append(selectR);

                        let searchR = '<button type="submit" onclick="javascript:search(false)">Search</button>' +
                            '<div id="resultsR"></div></div>';


                        $('#searchR').append(searchR);
                        $('#comboboxR').combobox();
                        //  Clear the right searchbox (should be updated if the #inputs changes
                        $('input')[3].value = '';
                    }
                };
                httpNew.send(paramsNew);
            } else {
                //  Prepare arrays for Kendall Tau Analysis
                rNamesArr = resObjArr.map(x =>x.name);
                rTempKendallArr = [];
                
                //  Populate array with the results returned by the search  
                for (let name in rNamesArr) {
                    rTempKendallArr.push([rNamesArr[name], (parseInt(name) + 1)]);
                }
                
                //  Add results from the dual search at the end of the rest
                let orderCount;
                
                //  Add right results to the left
                orderCount = lNamesArr.length + 1;
                for (let name in rNamesArr) {
                    if (lNamesArr.indexOf(rNamesArr[name]) === -1) {
                        lKendallArr.push([rNamesArr[name], orderCount]);
                        lNamesArr.push(rNamesArr[name]);
                        orderCount++;
                    }
                }
                
                //  Add left results to the right
                orderCount = rNamesArr.length + 1;
                for (let name in lNamesArr) {
                    if (rNamesArr.indexOf(lNamesArr[name]) === -1) {
                        rTempKendallArr.push([lNamesArr[name], orderCount]);
                        rNamesArr.push(lNamesArr[name]);
                        orderCount++;
                    }
                }
                
                //  Rearrange right results to match the order of the left ones
                //  based on the name of files
                rKendallArr = [];
                for (let name in lNamesArr) {
                    rKendallArr.push([lNamesArr[name], rTempKendallArr[
                        rNamesArr.indexOf(lNamesArr[name])
                    ][1]    // get the result order for said result
                    ]);
                }
                
                //  Check for results that are the same on both columns
                checkForDoubles();
            }
        }
    };
    
    http.send(params);
}

// Checks if there are same results on both searches, and highlights them
function checkForDoubles() {
    resetHighlights();
    var posChildren = document.getElementById("resultsL").childNodes;
    var negChildren = document.getElementById("resultsR").childNodes;
    var numOfResP = posChildren.length;
    var numOfResN = negChildren.length;
    let leftCount = 0;
    let rightCount = 0;
    
    let colorShift = baseColorHexInt / $('#resPerQuery')[0].value;
    let sameCount = 0;
    for(var i = 0; i < numOfResP ; i++) {
        if(posChildren[i].tagName !== 'DIV') continue;
        leftCount++;
        for(var j = 0; j < numOfResN ; j++) {
            if(negChildren[j].tagName !== 'DIV') continue;
            rightCount++;
            //  Get href
            var href1 = document.createElement('div');
            href1 = posChildren[i].getElementsByTagName('a')[0].href;
            var href2 = document.createElement('div');
            href2 = negChildren[j].getElementsByTagName('a')[0].href;
            
            //  if they have the same href
            if(href1 === href2) {
                sameCount++;
                posChildren[i].className = "same";
                negChildren[j].className = "same";
                let color = parseInt((baseColorHexInt - colorShift * sameCount).toString(16), 16).toString(16);
                posChildren[i].style.backgroundColor = '#' + color;
                negChildren[j].style.backgroundColor = '#' + color;
                posChildren[i].innerHTML += '<span>' + 'Match #' + rightCount + '</span>' + '<br />';
                negChildren[j].innerHTML += '<span>' + 'Match #' + leftCount + '</span>' + '<br />';
            }
        }
        rightCount = 0;
    }
}

// Resets highlights
function resetHighlights() {
    var posChildren = document.getElementById("resultsL").childNodes;
    var numOfRes = posChildren.length;
    for(var i = 0; i < numOfRes; i++) {
        if(posChildren[i].className === 'same') {
            //  this a result element which had a 
            
            //  remove <br>
            posChildren[i].removeChild(posChildren[i].children[posChildren[i].children.length - 1]);
            //  remove Matches ...
            posChildren[i].removeChild(posChildren[i].children[posChildren[i].children.length - 1]);
            posChildren[i].className = "unstyled";
        }
    }
}

//  Returns all possible permutations of given array of arrays 
function cartesianProduct(arr)
{
    return arr.reduce(function(a,b){
        return a.map(function(x){
            return b.map(function(y){
                return x.concat(y);
            });
        }).reduce(function(a,b){ return a.concat(b); },[]);
    }, [[]]);
}
