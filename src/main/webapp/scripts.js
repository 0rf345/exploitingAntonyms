var doneNess = [];
var resultsAllowed = 10;
var bingSE = false;

// A function which lets us know which function calls are done. When all are done, we rearrange the <select>s
function iAmDone(me) {
    doneNess[me] = true;
    var reallyDone = true;
    for(var i = 0; i < doneNess.length; i++) {
        reallyDone = reallyDone && doneNess[i];
    }

    if(reallyDone) {
        // Do Magic Stuff here
        console.log("All async calls must have completed now.");
        var elements = [];
        for (var i = 0; i < doneNess.length; i++) {
            var id = "word" + i;
            elements[i] = document.getElementById(id);
        }
        $("#switch").html("");
        for(var i = 0; i < elements.length; i++) {
            $("#switch").append(elements[i]);
        }
        var func = "'search(" + doneNess.length + ")'";
        document.getElementById("switch").innerHTML += "<input type=\"submit\" onclick=" + func + " value=\"Search\"/>";
    }
}

// Checks if there are same results on both searches, and highlights them
function checkForDoubles() {
    var posChildren = document.getElementById("searchL").childNodes;
    var negChildren = document.getElementById("searchR").childNodes;
    var numOfResP = posChildren.length;
    var numOfResN = negChildren.length;
    for(var i = 1; i < numOfResP ; i++) {
        for(var j = 1; j < numOfResN ; j++) {
            if(posChildren[i].getElementsByTagName("p")[2].innerHTML === negChildren[j].getElementsByTagName("p")[2].innerHTML ||
               posChildren[i].getElementsByTagName("p")[1].innerHTML === negChildren[j].getElementsByTagName("p")[1].innerHTML) {
                posChildren[i].className = "same";
                negChildren[j].className = "same";
                negChildren[j].getElementsByTagName('p')[3].innerHTML += '<b>Rank was: ' + i +
                        ' and is now: ' + j + '</b>';
            }
        }
    }
}

// Switched between using Google Search and Bing search
// We will be needing a new API key to keep using Bing
function switchSearch() {
    bingSE = !bingSE;
    if(bingSE) {
        $('#SE').val('Bing');
        $('#query').attr('placeholder', 'Search Bing');
    }
    else {
        $('#SE').val('Google');
        $('#query').attr('placeholder', 'Search Google');
    }
}

// Resets highlights
function resetHighlights() {
    var posChildren = document.getElementById("searchL").childNodes;
    var numOfRes = posChildren.length;
    for(var i = 1; i < numOfRes; i++) {
        posChildren[i].className = "unstyled";
    }
}

// TODO: Change this to async and use callback to post the results
function httpGet(theUrl) {
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.open( "GET", theUrl, false ); // false for synchronous request
    xmlHttp.send( null );
    return xmlHttp.responseText;
}

// Not Google Searching API
function notGoogleSearch(userQuery, pos) {
    var totallyLegalSearch = document.createElement( 'html' );
    var words = userQuery.split(' ');
    var query = '';
    for (var i = 0; i < words.length; i = i + 1) {
        query = query + words[i];
        // This let's us only add '+' when needed
        if(i !== words.length - 1) query = query + '+';
    }
    // URL for GETting the results
    var url = 'https://www.google.gr/search?q=' + query;
    totallyLegalSearch.innerHTML = httpGet(url);
    // Only use the part of the response we care about
    var divs = totallyLegalSearch.getElementsByClassName('rc');
    var nl = "<p>";
    
    // Prepare for the results
    if(pos) {
        $("#searchL").html("<center><font size='4' style='font-weight: bold'>Original Query</font></center>");
        $("#searchR").html("");
    }else{
        $("#searchR").html("<center><font size='4' style='font-weight: bold'>Dual Query</font></center>");
    }
    
    document.getElementById("numOfResults").value = divs.length;
    
    for (var i = 0; i < divs.length && i < resultsAllowed; i = i + 1) {

        // This catches featured snippets and skips them
        if(divs[i].getElementsByClassName('st')[0] === undefined) {
            console.log('Just skipped a featured snippet');
            continue;
        }
        
        var result = document.createElement('div');
        
        // Unwrap the info we want from each result and add it to the div
        var result = "<li class='unstyled'>";
                    result += nl + "<font size='3'><a href='"+ divs[i].getElementsByClassName('_Rm')[0]['innerText'] +"'><b>" +         // url
                            divs[i].getElementsByClassName('r')[0]['innerText'] + "</b></a></font>";                                    // title
                    result += nl + "<font size='2'><b id='green'>" + divs[i].getElementsByClassName('_Rm')[0]['innerText'] + "</b>";    // url
                    result += nl + divs[i].getElementsByClassName('st')[0]['innerText'] + "</font>" + nl;                               // snippet
                    result += "</li>";
                    
        // Populate our results
        if(pos) {
            $('#searchL').append(result);
        }else{
            $('#searchR').append(result);
        }
    }
    if(!pos) {
        resetHighlights();
        checkForDoubles();
    }
}


// Bing Search API
function bing(query, pos) {
    $(function () {
        var params = {
            // Request parameters
            "q": query,                 // Query to make
            "count": parseInt($("#numOfResults").val()),              // How many results to return
            "offset": "0",              // How many results to skup
            "mkt": "en-us",             // Market
            "safeSearch": "Moderate"    // Safe search for adult content
        };

        $.ajax({
            url: "https://api.cognitive.microsoft.com/bing/v5.0/search?" + $.param(params),
            beforeSend: function (xhrObj) {
                // Request headers
                xhrObj.setRequestHeader("Ocp-Apim-Subscription-Key", "cf26be0102344c40b661c028854d71b8");
                // old key e004b718ecbe423892f7da4e7b6a202c
            },
            type: "GET",
            // Request body
            data: "{body}"
        })
            .done(function (data) {
                var results = data.webPages.value;
        
                // This helps us in case the search query returns less results than expected
                document.getElementById("numOfResults").value = results.length;
                
                var nl = "<p>";
                // Check thether it is a positive or dual query
                if(pos) {
                    $("#searchL").html("<center><font size='4' style='font-weight: bold'>Original Query</font></center>");
                    $("#searchR").html("");
                }else{
                    $("#searchR").html("<center><font size='4' style='font-weight: bold'>Dual Query</font></center>");
                }
                for(var i = 0; i < results.length; i++) {
                    var content = "<li class='unstyled'>";
                    content += nl + "<font size='3'><a href='"+ results[i].url +"'><b>" + results[i].name + "</b></a></font>";
                    content += nl + "<font size='2'><b id='green'>" + results[i].displayUrl + "</b>";
                    content += nl + results[i].snippet + "</font>" + nl;
                    content += "</li>";
                    if(pos) {
                        document.getElementById("searchL").innerHTML += content;
                    }else{
                        document.getElementById("searchR").innerHTML += content;
                    }
                }
                if(!pos) {
                    resetHighlights();
                    checkForDoubles();
                }
            })
            .fail(function () {
                alert("error");
            });
    });
}

function search(num) {
    var query = "";
    for(var i = 0; i < num; i++) {
        var item = "#word" + i;
        query += $(item).val() + " ";

    }

    if(bingSE) bing(query, false);
    else notGoogleSearch(query, false);
}

// Gets antonyms for wordStr with index id calls iAmDone after it is done so we can sync the async calls
function processAnts(wordStr, index, last) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://words.bighugelabs.com/api/2/5dab07c8e8114c76de8aca8ae9e2171d/' + encodeURIComponent(wordStr) + '/json'); //?callback=my_callback_function
    xhr.onload = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
            var jsObj = JSON.parse(xhr.responseText);
            var ants = [];
            var counter = 0;
            var foundAnts = false;
            for (var family in jsObj) {
            
                if ("ant" in jsObj[family]) {
                    foundAnts = true;
                    for (var i = 0; i < jsObj[family].ant.length; i++) {
                        ants[counter++] = jsObj[family].ant[i];
                    }
                }
            }
            // Filter out multiple instances of antonyms
            ants = ants.filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });

            options = "<option value='"+wordStr+"'>"+wordStr+"</option>";

            if(foundAnts) {
                for (var i = 0; i < ants.length; i++) {
                    options += "<option value='"+ants[i]+"'>"+ants[i]+"</option>";
                }
            }

            if(foundAnts) {
                document.getElementById("switch").innerHTML += "<select id='word"+index+"'>" +
                    options + "</select>";
                iAmDone(index);
            } else {
                document.getElementById("switch").innerHTML += "<select id='word"+index+"' disabled>" +
                    options + "</select>";
                iAmDone(index);
            }
        } else if (xhr.status === 500) {
            console.log('Request failed: ' + xhr.responseText);
        } else if (xhr.status === 404) {
            console.log("Info on the word \""+ wordStr +"\" was not found by the API");
            document.getElementById("switch").innerHTML += "<select id='word"+index+"' disabled>" +
                "<option value='"+ wordStr +"'>"+ wordStr +"</option>" + "</select>";
            iAmDone(index);
        } else if (xhr.status === 303) {
            console.log('word not found: ' + wordStr);
        } else {
            console.log('Request failed with missing code: ' + xhr.status);
            console.log(xhr);
        }
    };
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send();
}

// Uses The Big Huge Thesaurus API to get the antonym and then passes the new query to the bing search
function negQueryPost(query) {
    $("#switch").html("");
    var antonyms = [];
    var antCounter = 0;
    var words = query.split(" ");

    // See if there are phrasal parts on the query
    while (query.match("\".*\"") !== null) {
        for(var word in words) {
            if (words[word][0] === "\"") {
                words[word] = words[word].replace("\"", "");
                query = query.replace("\"", "");
                for (var nextWord = Number(word) + 1; nextWord < words.length; nextWord++) {
                    if(words[nextWord].slice(-1) === "\"") {
                        words[nextWord] = words[nextWord].replace("\"", "");
                        words[word] += " " + words[nextWord];
                        words[nextWord] = "";
                        query = query.replace("\"", "");
                        break;
                    }
                    words[word] += " " + words[nextWord];
                    words[nextWord] = "";
                }
            }
        }

    }
    words = words.filter(function (word) {
        return word !== "";
    });

    // For syncing the async calls' results
    for(var i = 0; i < words.length; i++) {
        doneNess[i] = false;
    }

    var timeout = 100;
    optionId = 0;
    for(var word in words) {
        processAnts(words[word], Number(word), words.length - 1);
    }
}

function fudgeSearch() {
    var query = $("#query").val();
    if(bingSE) bing(query, true);
    else notGoogleSearch(query, true);
    negQueryPost(query);
}